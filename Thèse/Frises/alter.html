<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Timeline – Une slide</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Styles Knight Lab -->
  <link rel="stylesheet"
        href="https://cdn.knightlab.com/libs/timeline3/latest/css/timeline.css" />

  <!-- Librairie Knight Lab Timeline -->
  <script src="https://cdn.knightlab.com/libs/timeline3/latest/js/timeline.js"></script>

  <style>
    html, body { height:100%; margin:0; }
    #timeline-embed { height: 60vh; } /* on réduit un peu pour laisser de la place au contenu long */
    .tl-timegroup-message { opacity: 1 !important; color:#111 !important; font-weight:600; }

    /* zone de contenu long */
    #below-content {
      max-width: 900px;
      margin: 2rem auto;
      padding: 1rem 1.25rem;
      line-height: 1.6;
    }
    #below-content.hidden { display: none; }
    #below-content .card {
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      padding: 1.25rem;
      box-shadow: 0 2px 14px rgba(0,0,0,0.06);
      background: #fff;
    }
    #below-content h2 { margin: 0 0 .5rem 0; font-size: 1.25rem; }
    #below-content .meta { color:#6b7280; font-size:.95rem; margin-bottom:.75rem; }
  </style>
</head>
<body>
  <!-- Frise -->
  <div id="timeline-embed"></div>

  <!-- Contenu long sous la frise -->
  <div id="below-content" class="hidden">
    <div class="card" id="below-card"></div>
  </div>

  <script>
    // URL vers le JSON
    const timelineDataUrl = "data.json";

    // Options Timeline
    const options = {
      language: "fr",
      hash_bookmark: true, // garde les #event-... partageables
      start_at_slide: 0
    };

    // Initialisation
    const timeline = new TL.Timeline("timeline-embed", timelineDataUrl, options);

    // 1) contenus longs mappés par unique_id
    const longContents = {
      "showroom-01-pourquoi-frise": `
        <h2>Pourquoi une frise ? — La fabrique, par la pratique</h2>
        <div class="meta">Bloc relié à <code>showroom-01-pourquoi-frise</code></div>
        <p><i>Avant toute germination, il y a la préparation du sol.</i> Ici, nous rendons visible la logique
        qui a guidé la construction de l’artefact : une frise comme <b>écosystème narratif</b> pour accompagner
        l’émergence d’une thèse-vie.</p>
        <p>Ce « showroom » sert d’espace d’accueil : il explique <b>comment</b> la timeline est structurée
        (groupes, ères, transactions), et <b>pourquoi</b> ces choix favorisent une lecture située et attentive
        — conforme à une éthique du <i>design by care</i>.</p>
      `
      // ajoute ici d'autres entrées : "memo-passage-2025-10-12": `...`, etc.
    };

    // 2) helpers d’affichage
    const container = document.getElementById("below-content");
    const card = document.getElementById("below-card");

    function setBelowContentById(uniqueId) {
      const html = longContents[uniqueId];
      if (html) {
        card.innerHTML = html;
        container.classList.remove("hidden");
      } else {
        container.classList.add("hidden");
        card.innerHTML = "";
      }
    }

    // 3) extraction robuste de l'ID depuis l'événement 'change'
    function extractUniqueIdFromChangeEvent(e) {
      // TimelineJS fournit selon les versions : e.unique_id, e.slide.data.unique_id, ou via e.target.current_slide.data.unique_id
      return (
        e?.unique_id ||
        e?.slide?.data?.unique_id ||
        e?.data?.unique_id ||
        e?.target?.current_slide?.data?.unique_id ||
        null
      );
    }

    // 4) écoute des changements de slide (méthode principale)
    timeline.on('change', function (e) {
      const uid = extractUniqueIdFromChangeEvent(e);
      setBelowContentById(uid);
    });

    // 5) fallback : prise en compte du hash (utile pour liens profonds #event-...)
    function updateFromHash() {
      const m = (location.hash || "").match(/^#event-(.+)$/);
      if (m && m[1]) setBelowContentById(m[1]);
    }
    window.addEventListener("hashchange", updateFromHash);

    // 6) au chargement : tenter d’afficher si hash présent, sinon attendre le premier 'change'
    timeline.on('loaded', function (e) {
      updateFromHash();
      // si pas de hash, on force une première mise à jour à partir de la slide courante :
      const currentId =
        e?.target?.current_slide?.data?.unique_id || null;
      if (currentId && !location.hash) setBelowContentById(currentId);
    });
  </script>

  <style>
    html, body { height:100%; margin:0; }
    #timeline-embed { height:60vh; } /* laisse de la place pour le contenu long */

    .tl-timegroup-message { opacity: 1 !important; color:#111 !important; font-weight:600; }

    #below-content {
      max-width: 900px;
      margin: 2rem auto;
      padding: 1rem 1.25rem;
      line-height: 1.6;
    }
    #below-content.hidden { display: none; }
    #below-content .card {
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      padding: 1.25rem;
      box-shadow: 0 2px 14px rgba(0,0,0,0.06);
      background: #fff;
    }
    #below-content h2 { margin: 0 0 .5rem 0; font-size: 1.25rem; }
    #below-content .meta { color:#6b7280; font-size:.95rem; margin-bottom:.75rem; }
  </style>
</body>

</html>
